"""
" plotDNSTimeSeries class which is used to generate common dns time series plot.
" Accept a particular format of file as input. This kind of files can be generated by worker8D1
" see /src/integUtil/worker8D1TransPopT.py
" By Zhengping on 2019-02-26
"""

import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from datetime import datetime
from collections import Counter


class PlotDNSTimeSeries:
    def __init__(self, module_name, inner_ip, external_ip, qname,
                 time_start="2015-01-01", time_end="2020-12-31"):
        self.module = module_name
        self.inIP = inner_ip
        self.outIP = external_ip
        self.qname = qname
        self.time_range = PlotDNSTimeSeries._time_to_string((time_start, time_end))
        self.ax = plt.figure().add_subplot(111)
        self.data_by_ns = None

    @staticmethod
    def _get_color_for_dns(ns_type):
        """
        1637335 A
         836158 -
         469220 NB
         152778 AAAA
          87794 NBSTAT
          48353 PTR
          38025 *
          22239 CNAME
          11961 TXT
           6777 SRV
           5763 SOA
           3482 NS
           3037 MX
           2438 TKEY
                Others # Total: 15
        Status Type:
        1757288 -
        1434623 NOERROR
          75133 NXDOMAIN
          36371 REFUSED
          18727 SERVFAIL

        :param ns_type:
        :return:
        """
        trans_level = 0.2
        color_dict = {"A": (0.0, 0.8, 0.0, trans_level),
                      "AAAA": (0.0, 0, 0.8, trans_level),
                      "PTR": (0.8, 0, 0, trans_level),
                      "NS": (0, 0.4, 0.8, trans_level),
                      "SOA": (0.4, 0.4, 0, trans_level),
                      "NB": (0.6, 0, 0.6, trans_level),
                      # "MX": (0, 0, 0, trans_level),
                      "-": (1, 1, 1, trans_level)
                      }
        try:
            return color_dict[ns_type]
        except KeyError:
            return color_dict["-"]

    @staticmethod
    def _time_to_string(time_range):
        ts = time_range[0].split("-")
        te = time_range[1].split("-")
        ts_unix = int(datetime(int(ts[0]), int(ts[1]), int(ts[2]), 0, 0, 0).timestamp()) - 3600
        te_unix = int(datetime(int(te[0]), int(te[1]), int(te[2]), 0, 0, 0).timestamp()) - 3600
        time_range = {"start": ts_unix,
                      "end": te_unix}
        return time_range

    def _do_get_src_filename(self):
        filename = "../../exchange/batchedTransWork/%sTransTop100TSpecial.log" % self.module
        return filename

    def show_raw_helper(self, src_opt=False, pop_query=False, target_src=None, top_k=100):
        raw_data = self.load_raw_data(is_global=True)
        if src_opt:
            print("Provided raw external IPs are:")
            for index, key in zip(range(len(raw_data)), raw_data):
                print("%d\t%s" % (index+1, key))
        if pop_query:
            pop_query_counter = Counter()
            print("Get the top %d popular queries from current log file:" % (top_k))
            if not target_src:
                for key in raw_data:
                    for raw in raw_data[key]:
                        unique_query_fingerprint = raw[1]+ "_" + raw[2] + "_" + raw[5]
                        pop_query_counter[unique_query_fingerprint] += 1
                for key in pop_query_counter.most_common(top_k):
                    print(key)
            else:
                for key in raw_data:
                    for raw in raw_data[key]:
                        if raw[1] != target_src:
                            continue
                        unique_query_fingerprint = raw[1] + "_" + raw[2] + "_" + raw[5]
                        pop_query_counter[unique_query_fingerprint] += 1
                for key in pop_query_counter.most_common(top_k):
                    print(key)

    def show_helper(self, src_opt=False, dst_opt=False, qname_opt=False,
                    pop_query=False, top_k=100):
        if not self.data_by_ns:
            self.load_data_by_ns()
        if src_opt:
            self.src_set = set()
            print("The possible source IP are as follow:")
            for index, key in zip(range(len(self.data_by_ns)), self.data_by_ns.keys()):
                self.src_set.add(key)
                print("%d\t%s" % (index+1, key))

        if dst_opt:
            self.dst_set = set()
            print("The possible destination IP are as follow:")
            dst_ip_set = set(raw[2] for raw in self.load_raw_data())
            for index, key in zip(range(len(dst_ip_set)), dst_ip_set):
                self.dst_set.add(key)
                print("%d\t%s" % (index+1, key))

        if qname_opt:
            self.qname_set = set()
            print("The possible qnames are as follow:")
            qname_set = set(raw[5] for raw in self.load_raw_data())
            for index, key in zip(range(len(qname_set)), qname_set):
                self.qname_set.add(key)
                print("%d\t%s" % (index+1, key))

        if pop_query:
            pop_query_counter = Counter()
            print("Get the top %d popular queries from current IP Cluster:" % (top_k))
            for key in self.data_by_ns:
                for raw in self.data_by_ns[key]:
                    unique_query_fingerprint = raw[1]+ "_" + raw[2] + "_" + raw[5]
                    pop_query_counter[unique_query_fingerprint] += 1
            for key in pop_query_counter.most_common(top_k):
                print(key)

    def load_raw_data(self, is_global=False):
        filename = self._do_get_src_filename()
        if not is_global:
            with open(filename, 'r') as f:
                src_data = json.load(f)
            try:
                return src_data[self.outIP]
            except KeyError:
                print("Error: the requested outIP %s is not found from raw dataset" % (self.outIP))
                return None
        else:
            with open(filename, 'r') as f:
                src_data = json.load(f)
            return src_data

    def load_data_by_ns(self):
        raw_data = self.load_raw_data()
        if not raw_data:
            exit(-1)
        data_by_ns = {}
        for raw in raw_data:
            ts = int(float(raw[0]))
            if self.time_range["start"] <= ts <= self.time_range["end"] \
                    and raw[5] == self.qname:
                outIP_exact = raw[1]
                try:
                    data_by_ns[outIP_exact].append(raw)
                except KeyError:
                    data_by_ns[outIP_exact] = [raw]
        print(data_by_ns)
        # return data_by_ns
        self.data_by_ns = data_by_ns

    def gen_ns_pool(self):
        if not self.data_by_ns:
            self.load_data_by_ns()
        self.dst_set = set()
        dst_ip_set = set(raw[2] for raw in self.load_raw_data())
        ns_dict = {}
        index = 1
        for dst_ip in dst_ip_set:
            ns_dict[dst_ip] = "ns%s"%index
            index += 1
        return ns_dict

    def draw_valid_period(self, data_list):
        # color_active = (0.0, 0.6, 0.0, 0.2)
        """
        Draw the visible part in dns query, the range is painted as cubic,
        hence no line_style is required.
        :param data_list:
        :return:
        """
        ns_dict = self.gen_ns_pool()
        for entry in data_list:
            if entry[6] != "-":
                start_point = (int(float(entry[0])), 0-int(entry[4]))
                width = int(float(entry[7].split(",")[0]))
                height = int(entry[3]) + int(entry[4])
                color_active = PlotDNSTimeSeries._get_color_for_dns(entry[8])
                self.ax.add_patch(patches.Rectangle(start_point, width, height,
                                                    color=color_active,
                                                    label="Visible/%s"%(entry[8])))
                ns_name = ns_dict[entry[2]]
                if ns_name == "ns1":
                    y_axis = 50
                    ns_dot_color = "blue"
                elif ns_name == "ns2":
                    y_axis = -50
                    ns_dot_color = "red"
                else:
                    y_axis=0
                    ns_dot_color = "black"
                self.ax.scatter([int(float(entry[0]))], [y_axis],
                                color=ns_dot_color, marker=".", s=20)

    def draw_visible_query(self, data_list, line_style="-"):
        # color_visible_query = (0.0, 0.0, 0.8, 0.5)
        for entry in data_list:
            if entry[6] != "-":
                start_point = [int(float(entry[0])), int(entry[3])]
                end_point = [int(float(entry[0])), 0-int(entry[4])]
                color_visible_query = PlotDNSTimeSeries._get_color_for_dns(entry[8])
                self.ax.plot([start_point[0], end_point[0]], [start_point[1], end_point[1]],
                             color=color_visible_query, linestyle=line_style,
                             label="Visible/%s"%(entry[8]))

    def draw_invisible_query(self, data_list, line_style="-"):
        """
        Draw the invisible part in the dns_record list.
        :param data_list:
        :param line_style:
        :return:
        """
        # color_visible_query = (0.8, 0.0, 0.0, 0.2)
        ns_dict = self.gen_ns_pool()
        for entry in data_list:
            if entry[6] == "-":
                start_point = [int(float(entry[0])), int(entry[3])]
                end_point = [int(float(entry[0])), 0-int(entry[4])]
                color_visible_query = PlotDNSTimeSeries._get_color_for_dns(entry[8])
                color_visible_query = list(color_visible_query)
                color_visible_query[3] = 1
                color_visible_query = tuple(color_visible_query)
                self.ax.plot([start_point[0], end_point[0]], [start_point[1], end_point[1]],
                             color=color_visible_query, linestyle=line_style,
                             label="Invisible/%s"%(entry[8]))
            ns_name = ns_dict[entry[2]]
            if ns_name == "ns1":
                y_axis = 50
                ns_dot_color = "blue"
            elif ns_name == "ns2":
                y_axis = -50
                ns_dot_color = "red"
            else:
                y_axis = 0
                ns_dot_color = "black"
            self.ax.scatter([int(float(entry[0]))], [y_axis],
                            color=ns_dot_color, marker=".", s=20)

    def draw_essential(self, target_ns):
        try:
            data_by_ns = self.data_by_ns[target_ns]
            self.draw_valid_period(data_by_ns)
            self.draw_invisible_query(data_by_ns)
        except KeyError:
            print("The assigned key %s is not found in current data_dict" % (target_ns))

    def draw_systematic(self, target_ns_list=None):
        if not self.data_by_ns:
            self.load_data_by_ns()
        for target_ns in target_ns_list:
            self.draw_essential(target_ns)
        self.decoration()
        plt.show()

    def decoration(self):
        self.ax.plot([self.time_range["start"]-3600, self.time_range["end"]+3600],
                     [0, 0],
                     color="black",
                     linestyle="--")
        self.ax.set_xlim(self.time_range["start"], self.time_range["end"])
        max_y_lim = max([int(raw[3]) for raw in self.load_raw_data()] +
                        [int(raw[4]) for raw in self.load_raw_data()])
        self.ax.set_ylim(max_y_lim-10, max_y_lim+10)
        self.ax.set_xticks(list(range(self.time_range["start"],
                                      self.time_range["end"]+3600*24, 3600*24)))
        self.ax.set_xticklabels(["2018-09-%s" % str(d).zfill(2) for d in range(4, 8)], rotation=15)

        self.ax.set_yticks(list(range(0, max_y_lim+10, 50)) +
                           list(range(0, 0-max_y_lim-10, -50)))
        self.ax.set_yticklabels(list(range(0, max_y_lim+10, 50)) +
                                list(range(0, max_y_lim+10, 50)))

        handles, labels = plt.gca().get_legend_handles_labels()
        i = 1
        while i < len(labels):
            if labels[i] in labels[:i]:
                del (labels[i])
                del (handles[i])
            else:
                i += 1
        plt.legend(handles, labels, loc="best")
        # self.ax.legend(loc="best")




if __name__ == '__main__':
    # module_name = "inaurora"
    # inIP = "136.159.142.4"
    # outIP = "198.134.2.x"
    # qname = "ns2.auroralimaging.com"

    module_name = "incpsc"
    inIP = "136.159.2.4"
    # outIP = "208.69.32.x"
    outIP = "62.x.x.x"
    qname = "ns2.cpsc.ucalgary.ca"

    time_start = "2018-09-04"
    time_end = "2018-09-07"
    tester = PlotDNSTimeSeries(module_name, inIP, outIP, qname, time_start, time_end)
    # tester.draw_valid_period(tester.load_data_by_ns()["136.159.142.4"])
    # # tester.draw_visible_query(tester.load_data_by_ns()["136.159.142.4"])
    # tester.draw_invisible_query(tester.load_data_by_ns()["136.159.142.4"])
    tester.draw_systematic(["62.210.18.16"])
    # tester.decoration()
    # plt.show()
    # tester.show_raw_helper(src_opt=False, pop_query=True, target_src="62.210.18.16")
    # tester.show_helper(src_opt=False, dst_opt=False, qname_opt=False, pop_query=True)
